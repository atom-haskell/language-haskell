'fileTypes': []
'scopeName': 'annotation.liquidhaskell.haskell'
'macros':
  'identStartCharClass': '[\\p{Ll}_\\p{Lu}\\p{Lt}]'
  'identContCharClass': '[\\p{Ll}_\\p{Lu}\\p{Lt}\']'
  'identCharClass': '[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']'
  'functionNameOne': '[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*'
  'classNameOne': '[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*'
  'functionName': '(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*'
  'className': '[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*'
  'operatorChar': '(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))'
  'operator': '(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+'
  'operatorFun': '(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\))'
  'basicChar': '[\\ -\\[\\]-~]'
  'escapeChar': '\\\\(?:NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|[abfnrtv\\\\\\"\'\\&])'
  'octalChar': '(?:\\\\o[0-7]+)'
  'hexChar': '(?:\\\\x[0-9A-Fa-f]+)'
  'controlChar': '(?:\\\\\\^[A-Z@\\[\\]\\\\^_])'
  'character': '(?:[\\ -\\[\\]-~]|\\\\(?:NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|[abfnrtv\\\\\\"\'\\&])|(?:\\\\o[0-7]+)|(?:\\\\x[0-9A-Fa-f]+)|(?:\\\\\\^[A-Z@\\[\\]\\\\^_])|(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))'
  'functionList': '((?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*|(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\)))(?:(?:\\s*,\\s*)(?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*|(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\))))*)'
  'functionTypeDeclaration': '(?:(?:((?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*|(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\)))(?:(?:\\s*,\\s*)(?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*|(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\))))*)\\s*((?<!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))(?:::|∷)(?!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))))))'
  'doubleColonOperator': '(?<!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))(?:::|∷)(?!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))'
  'ctorTypeDeclaration': '(?:(?:((?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*|(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\)))(?:(?:\\s*,\\s*)(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*|(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\))))*))(?:\\s*((?<!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))(?:::|∷)(?!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))))))'
  'ctorArgs': '(?!deriving)(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*|(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*|(?:(?!deriving)(?:[\\w()\'→⇒\\[\\],]|->|=>)+\\s*)+)'
  'ctor': '(?:(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*)\\s*)(?:((?:(?!deriving)(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*|(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*|(?:(?!deriving)(?:[\\w()\'→⇒\\[\\],]|->|=>)+\\s*)+))(?:(?:\\s+)(?:(?!deriving)(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*|(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*|(?:(?!deriving)(?:[\\w()\'→⇒\\[\\],]|->|=>)+\\s*)+)))*)?))'
  'typeDeclOne': '(?:(?!(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))where(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])))(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*|(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*))'
  'typeDecl': '(?>(?:(?:(?!(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))where(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])))(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*|(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)))(?:\\s+(?:(?!(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))where(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])))(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*|(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)))*)'
  'indentChar': '[ \\t]'
  'indentBlockStart': '(?:\\G(?:\\s*\\w+\\s)?|^)([ \\t]*)'
  'indentBlockEnd': '(?:^(?!\\1[ \\t]|[ \\t]*$)|(?=@-}))'
  'indentBlockCont': '(?:^(?!\\1|[ \\t]*$)|(?=@-}))'
  'maybeBirdTrack': '(?:\\G(?:\\s*\\w+\\s)?|^)'
  'lb': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))'
  'lbrel': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}\'])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))'
  'rb': '(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
  'b': '(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))|(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])))'
'patterns': [
  {
    'include': '#class_decl'
  }
  {
    'include': '#instance_decl'
  }
  {
    'include': '#data_decl'
  }
  {
    'include': '#type_alias'
  }
  {
    'include': '#function_type_declaration'
  }
  {
    'include': '#lazy_function_type_signature'
  }
  {
    'include': '#haskell_expr'
  }
  {
    'include': '#comments'
  }
]
'repository':
  'block_comment':
    'patterns': [
      {
        'name': 'comment.block.haddock.haskell'
        'begin': '\\{-\\s*[|^]'
        'end': '-\\}'
        'applyEndPatternLast': 1
        'beginCaptures':
          '0':
            'name': 'punctuation.definition.comment.haddock.haskell'
        'endCaptures':
          '0':
            'name': 'punctuation.definition.comment.haddock.haskell'
        'patterns': [
          {
            'include': '#block_comment'
          }
        ]
      }
      {
        'name': 'comment.block.haskell'
        'begin': '\\{-'
        'end': '-\\}'
        'applyEndPatternLast': 1
        'beginCaptures':
          '0':
            'name': 'punctuation.definition.comment.block.start.haskell'
        'endCaptures':
          '0':
            'name': 'punctuation.definition.comment.block.end.haskell'
        'patterns': [
          {
            'include': '#block_comment'
          }
        ]
      }
    ]
  'comments':
    'patterns': [
      {
        'begin': '((?:\\G(?:\\s*\\w+\\s)?|^)[ \\t]+)?(?=--+\\s+[|^])'
        'end': '(?!\\G)'
        'patterns': [
          {
            'name': 'comment.line.double-dash.haddock.haskell'
            'begin': '(--+)\\s+([|^])'
            'end': '$'
            'beginCaptures':
              '1':
                'name': 'punctuation.definition.comment.haskell'
              '2':
                'name': 'punctuation.definition.comment.haddock.haskell'
          }
        ]
      }
      {
        'begin': '((?:\\G(?:\\s*\\w+\\s)?|^)[ \\t]+)?(?=--+(?!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))))'
        'end': '(?!\\G)'
        'patterns': [
          {
            'name': 'comment.line.double-dash.haskell'
            'begin': '--'
            'end': '$'
            'beginCaptures':
              '0':
                'name': 'punctuation.definition.comment.haskell'
          }
        ]
      }
      {
        'include': '#block_comment'
      }
    ]
  'characters':
    'patterns': [
      {
        'match': '\\\\(?:NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|[abfnrtv\\\\\\"\'\\&])'
        'name': 'constant.character.escape.haskell'
      }
      {
        'match': '(?:\\\\o[0-7]+)'
        'name': 'constant.character.escape.octal.haskell'
      }
      {
        'match': '(?:\\\\x[0-9A-Fa-f]+)'
        'name': 'constant.character.escape.hexadecimal.haskell'
      }
      {
        'match': '(?:\\\\\\^[A-Z@\\[\\]\\\\^_])'
        'name': 'constant.character.escape.control.haskell'
      }
    ]
  'module_exports':
    'patterns': [
      {
        'name': 'meta.declaration.exports.haskell'
        'begin': '\\('
        'end': '\\)'
        'applyEndPatternLast': 1
        'patterns': [
          {
            'include': '#comments'
          }
          {
            'include': '#c_preprocessor'
          }
          {
            'begin': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(module)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
            'end': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
            'beginCaptures':
              '1':
                'name': 'keyword.other.haskell'
            'endCaptures':
              '1':
                'name': 'support.other.module.haskell'
            'patterns': [
              {
                'include': '#invalid'
              }
            ]
          }
          {
            'include': '#function_name'
          }
          {
            'include': '#type_name'
          }
          {
            'include': '#comma'
          }
          {
            'name': 'meta.other.constructor-list.haskell'
            'begin': '(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))\\s*\\('
            'end': '\\)'
            'patterns': [
              {
                'include': '#comments'
              }
              {
                'include': '#c_preprocessor'
              }
              {
                'include': '#type_ctor'
              }
              {
                'include': '#attribute_name'
              }
              {
                'include': '#comma'
              }
              {
                'match': '\\.\\.'
                'name': 'keyword.operator.wildcard.haskell'
              }
            ]
          }
          {
            'include': '#infix_op'
          }
        ]
      }
    ]
  'module_name':
    'patterns': [
      {
        'name': 'support.other.module.haskell'
        'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
      }
    ]
  'module_name_prefix':
    'patterns': [
      {
        'name': 'support.other.module.haskell'
        'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.'
      }
    ]
  'pragma':
    'patterns': [
      {
        'name': 'meta.preprocessor.haskell'
        'begin': '\\{-#'
        'end': '#-\\}'
        'patterns': [
          {
            'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))((?i:NOTINLINE CONSTRUCTORLIKE|NOINLINE CONSTRUCTORLIKE|INLINE CONSTRUCTORLIKE|SPECIALISE NOTINLINE|SPECIALIZE NOTINLINE|SPECIALISE NOINLINE|SPECIALIZE NOINLINE|NOTINLINE CONLIKE|SPECIALISE INLINE|SPECIALIZE INLINE|NOINLINE CONLIKE|VECTORISE SCALAR|VECTORIZE SCALAR|OPTIONS_HADDOCK|INLINE CONLIKE|OPTIONS_DERIVE|OPTIONS_CATCH|OPTIONS_NHC98|OPTIONS_HUGS|OVERLAPPABLE|NOVECTORISE|NOVECTORIZE|OPTIONS_GHC|OPTIONS_JHC|OPTIONS_YHC|OVERLAPPING|DEPRECATED|INCOHERENT|INLINEABLE|SPECIALISE|SPECIALIZE|GENERATED|INLINABLE|NOTINLINE|VECTORISE|VECTORIZE|CONTRACT|LANGUAGE|NOINLINE|NOUNPACK|OVERLAPS|INCLUDE|MINIMAL|OPTIONS|WARNING|CFILES|INLINE|SOURCE|UNPACK|CTYPE|RULES|CORE|LINE|ANN|SCC))(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
            'name': 'keyword.other.preprocessor.haskell'
          }
        ]
      }
    ]
  'function_type_declaration':
    'patterns': [
      {
        'name': 'meta.function.type-declaration.haskell'
        'begin': '(?:\\G(?:\\s*\\w+\\s)?|^)([ \\t]*)(?:(?:((?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*|(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\)))(?:(?:\\s*,\\s*)(?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*|(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\))))*)\\s*((?<!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))(?:::|∷)(?!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))))))'
        'end': '(?:^(?!\\1[ \\t]|[ \\t]*$)|(?=@-}))|(?=(?<!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))(<-|=)(?!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))))'
        'contentName': 'meta.type-signature.haskell'
        'beginCaptures':
          '2':
            'patterns': [
              {
                'include': '#function_name'
              }
              {
                'include': '#infix_op'
              }
            ]
          '3':
            'name': 'keyword.other.double-colon.haskell'
        'patterns': [
          {
            'include': '#type_signature'
          }
        ]
      }
    ]
  'multiline_type_declaration':
    'patterns': [
      {
        'name': 'meta.multiline.type-declaration.haskell'
        'begin': '(?:\\G(?:\\s*\\w+\\s)?|^)([ \\t]*)((?<!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))(?:::|∷)(?!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))))'
        'end': '(?:^(?!\\1|[ \\t]*$)|(?=@-}))|(?=(?<!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))(<-|=)(?!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))))'
        'contentName': 'meta.type-signature.haskell'
        'beginCaptures':
          '2':
            'name': 'keyword.other.double-colon.haskell'
        'patterns': [
          {
            'include': '#type_signature'
          }
        ]
      }
    ]
  'lazy_function_type_signature':
    'patterns': [
      {
        'name': 'meta.function.type-declaration.haskell'
        'begin': '(?:\\G(?:\\s*\\w+\\s)?|^)([ \\t]*)(((?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*|(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\)))(?:(?:\\s*,\\s*)(?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*|(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\))))*))\\s*$'
        'end': '(?:^(?!\\1[ \\t]|[ \\t]*$)|(?=@-}))'
        'contentName': 'meta.type-signature.haskell'
        'beginCaptures':
          '2':
            'patterns': [
              {
                'include': '#function_name'
              }
              {
                'include': '#infix_op'
              }
            ]
        'patterns': [
          {
            'include': '#double_colon_operator'
          }
          {
            'include': '#type_signature'
          }
        ]
      }
    ]
  'double_colon_operator':
    'patterns': [
      {
        'name': 'keyword.other.double-colon.haskell'
        'match': '(?<!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))(?:::|∷)(?!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))'
      }
    ]
  'ctor_type_declaration':
    'patterns': [
      {
        'name': 'meta.ctor.type-declaration.haskell'
        'begin': '(?:\\G(?:\\s*\\w+\\s)?|^)([ \\t]*)(?:(?:((?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*|(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\)))(?:(?:\\s*,\\s*)(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*|(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\))))*))(?:\\s*((?<!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))(?:::|∷)(?!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))))))'
        'end': '(?:^(?!\\1[ \\t]|[ \\t]*$)|(?=@-}))'
        'contentName': 'meta.type-signature.haskell'
        'beginCaptures':
          '2':
            'patterns': [
              {
                'include': '#type_ctor'
              }
              {
                'include': '#infix_op'
              }
            ]
          '3':
            'name': 'keyword.other.double-colon.haskell'
        'patterns': [
          {
            'include': '#type_signature'
          }
        ]
      }
    ]
  'record_field_declaration':
    'patterns': [
      {
        'name': 'meta.record-field.type-declaration.haskell'
        'begin': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(?:(?:((?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*|(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\)))(?:(?:\\s*,\\s*)(?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*|(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\))))*)\\s*((?<!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))(?:::|∷)(?!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))))))'
        'end': '(?=(?:(?:((?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*|(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\)))(?:(?:\\s*,\\s*)(?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*|(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\))))*)\\s*((?<!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))(?:::|∷)(?!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))))))|})'
        'contentName': 'meta.type-signature.haskell'
        'beginCaptures':
          '1':
            'patterns': [
              {
                'include': '#attribute_name'
              }
              {
                'include': '#infix_op'
              }
            ]
          '2':
            'name': 'keyword.other.double-colon.haskell'
        'patterns': [
          {
            'include': '#type_signature'
          }
        ]
      }
    ]
  'type_signature':
    'patterns': [
      {
        'include': '#liquid_id'
      }
      {
        'include': '#liquid_type'
      }
      {
        'include': '#type_signature_hs'
      }
    ]
  'unit':
    'patterns': [
      {
        'name': 'constant.language.unit.haskell'
        'match': '\\(\\)'
      }
    ]
  'empty_list':
    'patterns': [
      {
        'name': 'constant.language.empty-list.haskell'
        'match': '\\[\\]'
      }
    ]
  'deriving':
    'patterns': [
      {
        'include': '#deriving_list'
      }
      {
        'include': '#deriving_simple'
      }
      {
        'include': '#deriving_keyword'
      }
    ]
  'deriving_keyword':
    'patterns': [
      {
        'name': 'meta.deriving.haskell'
        'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(deriving)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
        'captures':
          '1':
            'name': 'keyword.other.haskell'
      }
    ]
  'deriving_list':
    'patterns': [
      {
        'name': 'meta.deriving.haskell'
        'begin': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(deriving)\\s*\\('
        'end': '\\)'
        'beginCaptures':
          '1':
            'name': 'keyword.other.haskell'
        'patterns': [
          {
            'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
            'captures':
              '1':
                'name': 'entity.other.inherited-class.haskell'
          }
        ]
      }
    ]
  'deriving_simple':
    'patterns': [
      {
        'name': 'meta.deriving.haskell'
        'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(deriving)\\s*([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
        'captures':
          '1':
            'name': 'keyword.other.haskell'
          '2':
            'name': 'entity.other.inherited-class.haskell'
      }
    ]
  'infix_function':
    'patterns': [
      {
        'name': 'keyword.operator.function.infix.haskell'
        'match': '(`)(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(`)'
        'captures':
          '1':
            'name': 'punctuation.definition.entity.haskell'
          '2':
            'name': 'punctuation.definition.entity.haskell'
      }
    ]
  'quasi_quotes':
    'patterns': [
      {
        'begin': '(\\[)((?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)(\\|)'
        'end': '(\\|)(\\])'
        'beginCaptures':
          '1':
            'name': 'punctuation.definition.quasiquotes.begin.haskell'
          '2':
            'name': 'entity.name.tag.haskell'
            'patterns': [
              {
                'include': '#module_name_prefix'
              }
            ]
        'endCaptures':
          '2':
            'name': 'punctuation.definition.quasiquotes.end.haskell'
        'contentName': 'string.quoted.quasiquotes.haskell'
      }
    ]
  'module_decl':
    'patterns': [
      {
        'name': 'meta.declaration.module.haskell'
        'begin': '(?:\\G(?:\\s*\\w+\\s)?|^)([ \\t]*)(module)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
        'end': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(where)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))|(?:^(?!\\1[ \\t]|[ \\t]*$)|(?=@-}))'
        'beginCaptures':
          '2':
            'name': 'keyword.other.haskell'
        'endCaptures':
          '1':
            'name': 'keyword.other.haskell'
        'patterns': [
          {
            'include': '#comments'
          }
          {
            'include': '#module_name'
          }
          {
            'include': '#module_exports'
          }
          {
            'include': '#invalid'
          }
        ]
      }
    ]
  'hsig_decl':
    'patterns': [
      {
        'name': 'meta.declaration.module.haskell'
        'begin': '(?:\\G(?:\\s*\\w+\\s)?|^)([ \\t]*)(signature)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
        'end': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(where)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))|(?:^(?!\\1[ \\t]|[ \\t]*$)|(?=@-}))'
        'beginCaptures':
          '2':
            'name': 'keyword.other.haskell'
        'endCaptures':
          '1':
            'name': 'keyword.other.haskell'
        'patterns': [
          {
            'include': '#comments'
          }
          {
            'include': '#module_name'
          }
          {
            'include': '#module_exports'
          }
          {
            'include': '#invalid'
          }
        ]
      }
    ]
  'class_decl':
    'patterns': [
      {
        'name': 'meta.declaration.class.haskell'
        'begin': '(?:\\G(?:\\s*\\w+\\s)?|^)([ \\t]*)(class)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
        'end': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(where)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))|(?:^(?!\\1[ \\t]|[ \\t]*$)|(?=@-}))'
        'beginCaptures':
          '2':
            'name': 'keyword.other.class.haskell'
        'endCaptures':
          '1':
            'name': 'keyword.other.haskell'
        'patterns': [
          {
            'include': '#type_signature'
          }
        ]
      }
    ]
  'instance_decl':
    'patterns': [
      {
        'name': 'meta.declaration.instance.haskell'
        'begin': '(?:\\G(?:\\s*\\w+\\s)?|^)([ \\t]*)(instance)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
        'end': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(where)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))|(?:^(?!\\1[ \\t]|[ \\t]*$)|(?=@-}))'
        'contentName': 'meta.type-signature.haskell'
        'beginCaptures':
          '2':
            'name': 'keyword.other.haskell'
        'endCaptures':
          '1':
            'name': 'keyword.other.haskell'
        'patterns': [
          {
            'include': '#pragma'
          }
          {
            'include': '#type_signature'
          }
        ]
      }
    ]
  'deriving_instance_decl':
    'patterns': [
      {
        'name': 'meta.declaration.instance.deriving.haskell'
        'begin': '(?:\\G(?:\\s*\\w+\\s)?|^)([ \\t]*)(deriving\\s+instance)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
        'end': '(?:^(?!\\1[ \\t]|[ \\t]*$)|(?=@-}))'
        'contentName': 'meta.type-signature.haskell'
        'beginCaptures':
          '2':
            'name': 'keyword.other.haskell'
        'patterns': [
          {
            'include': '#pragma'
          }
          {
            'include': '#type_signature'
          }
        ]
      }
    ]
  'foreign_import':
    'patterns': [
      {
        'name': 'meta.foreign.haskell'
        'begin': '(?:\\G(?:\\s*\\w+\\s)?|^)([ \\t]*)(foreign)\\s+(import|export)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
        'end': '(?:^(?!\\1[ \\t]|[ \\t]*$)|(?=@-}))'
        'beginCaptures':
          '2':
            'name': 'keyword.other.haskell'
          '3':
            'name': 'keyword.other.haskell'
        'patterns': [
          {
            'match': '(?:un)?safe'
            'captures':
              '0':
                'name': 'keyword.other.haskell'
          }
          {
            'include': '#function_type_declaration'
          }
          {
            'include': '#haskell_expr'
          }
          {
            'include': '#comments'
          }
        ]
      }
    ]
  'regular_import':
    'patterns': [
      {
        'name': 'meta.import.haskell'
        'begin': '(?:\\G(?:\\s*\\w+\\s)?|^)([ \\t]*)(import)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
        'end': '(?:^(?!\\1[ \\t]|[ \\t]*$)|(?=@-}))'
        'beginCaptures':
          '2':
            'name': 'keyword.other.haskell'
        'patterns': [
          {
            'include': '#module_name'
          }
          {
            'include': '#module_exports'
          }
          {
            'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(qualified|as|hiding)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
            'captures':
              '1':
                'name': 'keyword.other.haskell'
          }
          {
            'include': '#comments'
          }
        ]
      }
    ]
  'data_decl':
    'patterns': [
      {
        'name': 'meta.declaration.type.data.haskell'
        'begin': '(?:\\G(?:\\s*\\w+\\s)?|^)([ \\t]*)(data|newtype)\\s+((?:(?!=|where).)*)'
        'end': '(?:^(?!\\1[ \\t]|[ \\t]*$)|(?=@-}))'
        'beginCaptures':
          '2':
            'name': 'keyword.other.data.haskell'
          '3':
            'name': 'meta.type-signature.haskell'
            'patterns': [
              {
                'include': '#family_and_instance'
              }
              {
                'include': '#type_signature'
              }
            ]
        'patterns': [
          {
            'include': '#comments'
          }
          {
            'include': '#where'
          }
          {
            'include': '#deriving'
          }
          {
            'include': '#assignment_op'
          }
          {
            'match': '(?:(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*)\\s*)(?:((?:(?!deriving)(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*|(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*|(?:(?!deriving)(?:[\\w()\'→⇒\\[\\],]|->|=>)+\\s*)+))(?:(?:\\s+)(?:(?!deriving)(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*|(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*|(?:(?!deriving)(?:[\\w()\'→⇒\\[\\],]|->|=>)+\\s*)+)))*)?))'
            'captures':
              '1':
                'patterns': [
                  {
                    'include': '#type_ctor'
                  }
                ]
              '2':
                'name': 'meta.type-signature.haskell'
                'patterns': [
                  {
                    'include': '#type_signature'
                  }
                ]
          }
          {
            'match': '\\|'
            'captures':
              '0':
                'name': 'punctuation.separator.pipe.haskell'
          }
          {
            'name': 'meta.declaration.type.data.record.block.haskell'
            'begin': '\\{'
            'beginCaptures':
              '0':
                'name': 'keyword.operator.record.begin.haskell'
            'end': '\\}'
            'endCaptures':
              '0':
                'name': 'keyword.operator.record.end.haskell'
            'patterns': [
              {
                'include': '#comments'
              }
              {
                'include': '#comma'
              }
              {
                'include': '#record_field_declaration'
              }
            ]
          }
          {
            'include': '#ctor_type_declaration'
          }
        ]
      }
    ]
  'type_alias':
    'patterns': [
      {
        'name': 'meta.declaration.type.type.haskell'
        'begin': '(?:\\G(?:\\s*\\w+\\s)?|^)([ \\t]*)(type)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
        'end': '(?:^(?!\\1[ \\t]|[ \\t]*$)|(?=@-}))'
        'contentName': 'meta.type-signature.haskell'
        'beginCaptures':
          '2':
            'name': 'keyword.other.type.haskell'
        'patterns': [
          {
            'include': '#comments'
          }
          {
            'include': '#family_and_instance'
          }
          {
            'include': '#where'
          }
          {
            'include': '#assignment_op'
          }
          {
            'include': '#type_signature'
          }
        ]
      }
    ]
  'keywords':
    'patterns': [
      {
        'name': 'keyword.other.$1.haskell'
        'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(deriving|where|data|type|newtype)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
      }
      {
        'name': 'keyword.operator.$1.haskell'
        'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(infix[lr]?)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
      }
      {
        'name': 'keyword.control.$1.haskell'
        'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(do|if|then|else|case|of|let|in|default|mdo|rec|proc)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
      }
    ]
  'c_preprocessor':
    'patterns': [
      {
        'name': 'meta.preprocessor.c.haskell'
        'begin': '(?:\\G(?:\\s*\\w+\\s)?|^)(?=#)'
        'end': '(?<!\\\\)(?=$)'
        'patterns': [
          {
            'match': '^#\\S+'
            'name': 'keyword.control.c.haskell'
          }
        ]
      }
    ]
  'string':
    'patterns': [
      {
        'name': 'string.quoted.double.haskell'
        'begin': '"'
        'end': '"'
        'beginCaptures':
          '0':
            'name': 'punctuation.definition.string.begin.haskell'
        'endCaptures':
          '0':
            'name': 'punctuation.definition.string.end.haskell'
        'patterns': [
          {
            'include': '#characters'
          }
          {
            'begin': '\\\\\\s'
            'end': '\\\\'
            'beginCaptures':
              '0':
                'name': 'markup.other.escape.newline.begin.haskell'
            'endCaptures':
              '0':
                'name': 'markup.other.escape.newline.end.haskell'
            'patterns': [
              {
                'include': '#invalid'
              }
            ]
          }
        ]
      }
    ]
  'newline_escape':
    'patterns': [
      {
        'name': 'markup.other.escape.newline.haskell'
        'match': '\\\\$'
      }
    ]
  'quoted_character':
    'patterns': [
      {
        'name': 'string.quoted.single.haskell'
        'match': '(\')((?:[\\ -\\[\\]-~]|\\\\(?:NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|[abfnrtv\\\\\\"\'\\&])|(?:\\\\o[0-7]+)|(?:\\\\x[0-9A-Fa-f]+)|(?:\\\\\\^[A-Z@\\[\\]\\\\^_])|(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))))(\')'
        'captures':
          '1':
            'name': 'punctuation.definition.string.begin.haskell'
          '2':
            'patterns': [
              {
                'include': '#characters'
              }
            ]
          '3':
            'name': 'punctuation.definition.string.end.haskell'
      }
    ]
  'scoped_type':
    'patterns': [
      {
        'match': '\\(((?<paren>(?:[^\\(\\)]|\\(\\g<paren>\\))*)(?<!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))(?:::|∷)(?!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))(?<paren2>(?:[^\\(\\)]|\\(\\g<paren2>\\))*))\\)'
        'captures':
          '1':
            'patterns': [
              {
                'include': '#haskell_expr'
              }
            ]
      }
      {
        'match': '((?<!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))(?:::|∷)(?!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))))(.*?)(?=(?<!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))(<-|=)(?!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))|$)'
        'captures':
          '1':
            'name': 'keyword.other.double-colon.haskell'
          '2':
            'name': 'meta.type-signature.haskell'
            'patterns': [
              {
                'include': '#type_signature'
              }
            ]
      }
    ]
  'scoped_type_override':
    'patterns': [
      {
        'match': '(?:\\G(?:\\s*\\w+\\s)?|^)([ \\t]*)(?:(?:((?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*|(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\)))(?:(?:\\s*,\\s*)(?:(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*|(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\))))*)\\s*((?<!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))(?:::|∷)(?!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))))))(.*)(?<!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))(<-|=)(?!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))'
        'captures':
          '2':
            'patterns': [
              {
                'include': '#identifier'
              }
            ]
          '3':
            'name': 'keyword.other.double-colon.haskell'
          '4':
            'name': 'meta.type-signature.haskell'
            'patterns': [
              {
                'include': '#type_signature'
              }
            ]
          '5':
            'patterns': [
              {
                'include': '#assignment_op'
              }
              {
                'include': '#operator'
              }
            ]
      }
    ]
  'comma':
    'patterns': [
      {
        'name': 'punctuation.separator.comma.haskell'
        'match': ','
      }
    ]
  'lit_num':
    'patterns': [
      {
        'name': 'constant.numeric.hexfloat.haskell'
        'match': '0[xX][0-9a-fA-F_]*(?:\\.[0-9a-fA-F_]+(?:[pP][+-]?[0-9_]+)?|[pP][+-]?[0-9_]+)'
      }
      {
        'name': 'constant.numeric.hexadecimal.haskell'
        'match': '0[xX][_0-9a-fA-F]+'
      }
      {
        'name': 'constant.numeric.octal.haskell'
        'match': '0[oO][_0-7]+'
      }
      {
        'name': 'constant.numeric.binary.haskell'
        'match': '0[bB][_01]+'
      }
      {
        'name': 'constant.numeric.float.haskell'
        'match': '[0-9][0-9_]*(?:\\.[0-9_]+(?:[eE][+-]?[0-9_]+)?|[eE][+-]?[0-9_]+)'
      }
      {
        'name': 'constant.numeric.decimal.haskell'
        'match': '[0-9][_0-9]*'
      }
    ]
  'operator':
    'patterns': [
      {
        'name': 'keyword.operator.haskell'
        'match': '(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+'
        'captures':
          '0':
            'patterns': [
              {
                'include': '#module_name_prefix'
              }
              {
                'name': 'support.operator.prelude.haskell'
                'match': '^(\\!\\!|\\$\\!|\\$|\\&\\&|\\*|\\*\\*|\\*\\>|\\+|\\+\\+|\\-|\\.|\\/|\\/\\=|\\<\\$|\\<\\$\\>|\\<|\\<\\*|\\<\\*\\>|\\<\\=|\\=\\<\\<|\\=\\=|\\>|\\>\\=|\\>\\>|\\>\\>\\=|\\^|\\^\\^|\\|\\|)$'
              }
            ]
      }
    ]
  'infix_op':
    'patterns': [
      {
        'name': 'entity.name.function.operator.haskell'
        'match': '(?:\\((?!--+\\))(?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+\\))'
        'captures':
          '0':
            'patterns': [
              {
                'include': '#module_name_prefix'
              }
              {
                'name': 'support.operator.prelude.haskell'
                'match': '^\\((\\!\\!|\\$\\!|\\$|\\&\\&|\\*|\\*\\*|\\*\\>|\\+|\\+\\+|\\-|\\.|\\/|\\/\\=|\\<\\$|\\<\\$\\>|\\<|\\<\\*|\\<\\*\\>|\\<\\=|\\=\\<\\<|\\=\\=|\\>|\\>\\=|\\>\\>|\\>\\>\\=|\\^|\\^\\^|\\|\\|)\\)$'
              }
            ]
      }
    ]
  'identifier':
    'patterns': [
      {
        'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
        'name': 'identifier.haskell'
        'captures':
          '0':
            'patterns': [
              {
                'include': '#module_name_prefix'
              }
              {
                'name': 'support.function.prelude.$1.haskell'
                'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(abs|acos|acosh|all|and|any|appendFile|asTypeOf|asin|asinh|atan|atan2|atanh|break|ceiling|compare|concat|concatMap|const|cos|cosh|curry|cycle|decodeFloat|div|divMod|drop|dropWhile|either|elem|encodeFloat|enumFrom|enumFromThen|enumFromThenTo|enumFromTo|error|errorWithoutStackTrace|even|exp|exponent|fail|filter|flip|floatDigits|floatRadix|floatRange|floor|fmap|foldMap|foldl|foldl1|foldr|foldr1|fromEnum|fromInteger|fromIntegral|fromRational|fst|gcd|getChar|getContents|getLine|head|id|init|interact|ioError|isDenormalized|isIEEE|isInfinite|isNaN|isNegativeZero|iterate|last|lcm|length|lex|lines|log|logBase|lookup|map|mapM|mapM_|mappend|max|maxBound|maximum|maybe|mconcat|mempty|min|minBound|minimum|mod|negate|not|notElem|null|odd|or|otherwise|pi|pred|print|product|properFraction|pure|putChar|putStr|putStrLn|quot|quotRem|read|readFile|readIO|readList|readLn|readParen|reads|readsPrec|realToFrac|recip|rem|repeat|replicate|return|reverse|round|scaleFloat|scanl|scanl1|scanr|scanr1|seq|sequence|sequenceA|sequence_|show|showChar|showList|showParen|showString|shows|showsPrec|significand|signum|sin|sinh|snd|span|splitAt|sqrt|subtract|succ|sum|tail|take|takeWhile|tan|tanh|toEnum|toInteger|toRational|traverse|truncate|uncurry|undefined|unlines|until|unwords|unzip|unzip3|userError|words|writeFile|zip|zip3|zipWith|zipWith3)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
              }
            ]
      }
    ]
  'type_name':
    'patterns': [
      {
        'name': 'entity.name.type.haskell'
        'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
        'captures':
          '0':
            'patterns': [
              {
                'include': '#module_name_prefix'
              }
              {
                'name': 'entity.other.inherited-class.prelude.$1.haskell'
                'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(Applicative|Bounded|Enum|Eq|Floating|Foldable|Fractional|Functor|Integral|Monad|Monoid|Num|Ord|Read|Real|RealFloat|RealFrac|Show|Traversable)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
              }
              {
                'name': 'support.class.prelude.$1.haskell'
                'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(Either|FilePath|IO|IOError|Integer|Ordering|Rational|ReadS|ShowS|String|Bool|Char|Double|Float|Int|Just|Maybe|Nothing|Word)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
              }
            ]
      }
    ]
  'type_ctor':
    'patterns': [
      {
        'name': 'entity.name.tag.haskell'
        'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
        'captures':
          '0':
            'patterns': [
              {
                'include': '#module_name_prefix'
              }
              {
                'name': 'support.tag.prelude.$1.haskell'
                'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(EQ|GT|LT|Left|Right|True|False)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
              }
            ]
      }
    ]
  'where':
    'patterns': [
      {
        'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))where(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
        'name': 'keyword.other.haskell'
      }
    ]
  'family_and_instance':
    'patterns': [
      {
        'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(family|instance)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
        'name': 'keyword.other.haskell'
      }
    ]
  'invalid':
    'patterns': [
      {
        'match': '\\S+'
        'name': 'invalid.illegal.character-not-allowed-here.haskell'
      }
    ]
  'function_name':
    'patterns': [
      {
        'name': 'entity.name.function.haskell'
        'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
      }
    ]
  'assignment_op':
    'patterns': [
      {
        'match': '='
        'captures':
          '0':
            'name': 'keyword.operator.assignment.haskell'
      }
    ]
  'attribute_name':
    'patterns': [
      {
        'name': 'entity.other.attribute-name.haskell'
        'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
      }
    ]
  'liquidhaskell_annotation':
    'patterns': [
      {
        'name': 'block.liquidhaskell.haskell'
        'contentName': 'block.liquidhaskell.annotation.haskell'
        'begin': '\\{-@(?!#)'
        'end': '@-\\}'
        'patterns': [
          {
            'include': 'annotation.liquidhaskell.haskell'
          }
        ]
      }
    ]
  'shebang':
    'patterns': [
      {
        'name': 'comment.line.shebang.haskell'
        'match': '^\\#\\!.*\\brunhaskell\\b.*$'
      }
    ]
  'haskell_expr':
    'patterns': [
      {
        'include': '#infix_function'
      }
      {
        'include': '#unit'
      }
      {
        'include': '#empty_list'
      }
      {
        'include': '#quasi_quotes'
      }
      {
        'include': '#keywords'
      }
      {
        'include': '#pragma'
      }
      {
        'include': '#string'
      }
      {
        'include': '#newline_escape'
      }
      {
        'include': '#quoted_character'
      }
      {
        'include': '#comments'
      }
      {
        'include': '#infix_op'
      }
      {
        'include': '#comma'
      }
      {
        'include': '#lit_num'
      }
      {
        'include': '#scoped_type'
      }
      {
        'include': '#operator'
      }
      {
        'include': '#identifier'
      }
      {
        'include': '#type_ctor'
      }
    ]
  'common_toplevel':
    'patterns': [
      {
        'include': '#class_decl'
      }
      {
        'include': '#instance_decl'
      }
      {
        'include': '#deriving_instance_decl'
      }
      {
        'include': '#foreign_import'
      }
      {
        'include': '#regular_import'
      }
      {
        'include': '#data_decl'
      }
      {
        'include': '#type_alias'
      }
      {
        'include': '#c_preprocessor'
      }
    ]
  'function_type_declaration_with_scoped_type':
    'patterns': [
      {
        'include': '#scoped_type_override'
      }
      {
        'include': '#function_type_declaration'
      }
      {
        'include': '#multiline_type_declaration'
      }
    ]
  'haskell_toplevel':
    'patterns': [
      {
        'include': '#liquidhaskell_annotation'
      }
      {
        'include': '#common_toplevel'
      }
      {
        'include': '#function_type_declaration_with_scoped_type'
      }
      {
        'include': '#haskell_expr'
      }
    ]
  'hsig_toplevel':
    'patterns': [
      {
        'include': '#common_toplevel'
      }
      {
        'include': '#function_type_declaration'
      }
      {
        'include': '#lazy_function_type_signature'
      }
      {
        'include': '#comments'
      }
    ]
  'haskell_source':
    'patterns': [
      {
        'include': '#shebang'
      }
      {
        'include': '#module_decl'
      }
      {
        'include': '#haskell_toplevel'
      }
    ]
  'hsig_source':
    'patterns': [
      {
        'include': '#hsig_decl'
      }
      {
        'include': '#hsig_toplevel'
      }
    ]
  'type_signature_hs':
    'patterns': [
      {
        'include': '#pragma'
      }
      {
        'include': '#comments'
      }
      {
        'name': 'keyword.other.forall.haskell'
        'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))forall(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
      }
      {
        'match': '\'(\\(\\))'
        'name': 'constant.language.unit.promoted.haskell'
        'captures':
          '1':
            'patterns': [
              {
                'include': '#unit'
              }
            ]
      }
      {
        'include': '#unit'
      }
      {
        'match': '\'(\\[\\])'
        'name': 'constant.language.empty-list.promoted.haskell'
        'captures':
          '1':
            'patterns': [
              {
                'include': '#empty_list'
              }
            ]
      }
      {
        'include': '#empty_list'
      }
      {
        'include': '#string'
      }
      {
        'name': 'keyword.other.arrow.haskell'
        'match': '(?<!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))(->|→)(?!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))'
      }
      {
        'name': 'keyword.other.big-arrow.haskell'
        'match': '(?<!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))(=>|⇒)(?!(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\'])))'
      }
      {
        'match': '\'((?:(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?(?:[\\p{S}\\p{P}](?<![(),;\\[\\]`{}_"\']))+)'
        'name': 'keyword.operator.promoted.haskell'
        'captures':
          '1':
            'patterns': [
              {
                'include': '#operator'
              }
            ]
      }
      {
        'include': '#operator'
      }
      {
        'name': 'variable.other.generic-type.haskell'
        'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
      }
      {
        'name': 'entity.name.type.promoted.haskell'
        'match': '(?:(?=[\\p{Ll}_\\p{Lu}\\p{Lt}\'])(?<![\\p{Ll}_\\p{Lu}\\p{Lt}\']))\'([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*)(?:(?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'])(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']))'
        'captures':
          '1':
            'patterns': [
              {
                'include': '#type_name'
              }
            ]
      }
      {
        'include': '#type_name'
      }
      {
        'include': '#lit_num'
      }
    ]
  'liquid_id':
    'patterns': [
      {
        'match': '(?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*)*\\.)?[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*\\s*:'
        'captures':
          '0':
            'patterns': [
              {
                'include': '#identifier'
              }
            ]
      }
    ]
  'liquid_type':
    'patterns': [
      {
        'begin': '\\{'
        'end': '\\}'
        'name': 'liquid.type.haskell'
        'patterns': [
          {
            'match': '\\G(.*?)\\|'
            'captures':
              '1':
                'patterns': [
                  {
                    'include': '#type_signature'
                  }
                ]
          }
          {
            'include': '#haskell_expr'
          }
        ]
      }
    ]